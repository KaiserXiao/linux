gcc  --shared    -fpic    -o libsub.so     sub.o-fpic  产生位置无关码位置无关码就是可以在进程的任意内存位置执行的目标码，动态链接库必须使用。-shared 生成共享库上述gcc命令生成libsub.sogcc   -o main       main.c     -L  .    -lsub此时生成main可执行文件，但执行不了因为DLL在使用时会查找/usr/lib 和/lib 目录下的DLL此时根本找不到这个libsub.so前面代码如果一样会生成如下的errerror while loading shared libraries: libsub.so: cannot open shared object file: No such file or directory那么怎么办？方法1mv  ./libsub.so /usr/lib 注意这里可能出现的权限问题删的时候也一样mv   /usr/lib/libsub.so  .方法2 假设libsub.so 在/home/linux中设置环境变量export  LD_LIBRARY_PATH =/home/linux上述命令仅仅修改此Terminal的环境变量查看有没有修改echo $LD_LIBRARY_PATH关闭此Terminal环境变量就恢复了方法3切换到root在/etc/ld.so.config中加入我们我们生成库的目录的绝对地址然后ldconfig  /etc/ld.so.config注意实验结束后要把此目录改回来要root权限ld.so.config中存放链接器和加载器搜索共享库时检查的目录默认从/usr/lib中读取总结：最后是一个对比静态库比较大，但不受环境影响动态库比较小，但易受环境编译影响